function p = Param(varargin)
% MWPI.Param
% 
% Description:	get a mwpi parameter
% 
% Syntax:	p = MWPI.Param(f1,...,fN)
% 
% In:
% 	fK	- the the Kth parameter field
% 
% Out:
% 	p	- the parameter value
%
% Example:
%	p = MWPI.Param('color','back');
%
% Updated: 2015-06-24

% struct to hold param values
persistent P;

if isempty(P)
   P = InitializeP;
end

% get parameter value
p = P;
for k = 1:nargin
    field = varargin{k};
    switch class(field)
        case 'char'
            if isfield(p, field)
                p = p.(field);
            else
                p = [];
                return;
            end
        otherwise
            if iscell(p) % if we're indexing into a cell
                p = p{field};
            else
                p = [];
                return;
            end
    end
end

end

%----------------------------------------------------------------------%

function P = InitializeP
	%--experiment parameters----------------------------------
	P = struct;
    
    P.stim = struct(...
        'class',       1:4 ...
        );
	
	P.trTime = 2; % seconds
	% all remaining times are in trs.
	
	P.exp = struct;
	P.exp.nRun = 10;
	P.exp.block = struct;
		P.exp.block.prompt = struct;
			P.exp.block.prompt.stim = struct(...
				'time',	1.5 ...
				);
			
			P.exp.block.prompt.cue = struct(...
				'tBlankPre',	0.1, ...
				'tCue',			0.1, ...
				'tBlankPost',	0.3  ...
				);
				P.exp.block.prompt.cue.time = P.exp.block.prompt.cue.tBlankPre +...
											  P.exp.block.prompt.cue.tShow +...
											  P.exp.block.prompt.cue.tBlankPost;
										  
			P.exp.block.prompt.time = P.exp.block.prompt.stim.time + ...
									  P.exp.block.prompt.cue.time;
		
		P.exp.block.retention = struct(...
			'time',	5		...
			);
		
		P.exp.block.test = struct(...
			'tBlank',	0.25, ...
			'tTest',	0.75  ...
			);
			P.exp.block.test.time = P.exp.block.test.tBlank + ...
									P.exp.block.test.tTest;
			
		P.exp.block.feedback = struct(...
			'tBlank',	0.5,  ...
			'tFeedback',0.5	  ...
			);
			P.exp.block.feedback.time = P.exp.block.feedback.tBlank + ...
										P.exp.block.feedback.tFeedback;
	
	P.exp.block.time = P.exp.block.prompt.time + ...
					   P.exp.block.retention.time + ...
					   P.exp.block.test.time + ...
					   P.exp.block.feedback.time;
	
	P.exp.rest.time = 4;
    
	P.exp.run.nCondRep = 3; % number of times to repeat the 4 classes
	P.exp.run.nBlock =	numel(P.stim.class) * P.exp.run.nCondRep;
	P.exp.run.time = P.exp.block.time * P.exp.run.nBlock + ...
					 P.exp.rest.time * (P.exp.run.nBlock + 1);	
				 
	% parameter modifications for the practice run:

	P.practice = struct(...
        'nRun',             1,					  ...
		'run',				struct('nCondRep',10) ...
	);
	P.practice.run.nBlock = numel(P.stim.class) * P.practice.run.nCondRep;
    
    P.reward = struct(...
        'base'  ,   20, ...
        'max'   ,   40, ...
        'penalty',  5   ... penalty is this number times reward
        );
    P.reward.rewardPerBlock = (P.reward.max - P.reward.base) / P.exp.nProbeTotal;
    P.reward.penaltyPerBlock = P.reward.rewardPerBlock * P.reward.penalty;
    
	%--display parameters-------------------------------------
	P.color = struct(...
		'back',     [127 127 127], ...
		'fore',     [0   0   0  ], ...
		'yes',      [0   255 0  ], ...
		'no',       [255 0   0  ] ...
		);
	P.text = struct(...
		'size',     0.75,     ... (d.v.a.)
		'family',   'Arial',...
        'fbOffset',   5,      ...
        'colNorm',  'black',...
        'colYes',   'green',...
        'colNo',    'red',  ...
        'sizeDone', 3.5,    ... (d.v.a.)
        'colDone',  'red'  ...
		);
	P.size = struct(... d.v.a. unless otherwise indicated
		'stimpx',   	400,	...
		'stim', 		10,		...
        'probe',        6.5    ...
		);
    
    %--input parameters---------------------------------------
    P.key = struct(...
        'response'  ,   {{'left','up','right'}}, ...
        'noMatch'   ,   'left',                  ...
        'classMatch',   'up'  ,                  ...
        'exactMatch',   'right'                  ...
        );
end

