function p = Param(varargin)
% MWPI.Param
% 
% Description:	get a mwpi parameter
% 
% Syntax:	p = MWPI.Param(f1,...,fN)
% 
% In:
% 	fK	- the the Kth parameter field
% 
% Out:
% 	p	- the parameter value
%
% Example:
%	p = MWPI.Param('color','back');
%
% Updated: 2015-06-24

% struct to hold param values
persistent P;

if isempty(P)
   P = InitializeP;
end

% get parameter value
p = P;
for k = 1:nargin
    field = varargin{k};
    switch class(field)
        case 'char'
            if isfield(p, field)
                p = p.(field);
            else
                p = [];
                return;
            end
        otherwise
            if iscell(p) % if we're indexing into a cell
                p = p{field};
            else
                p = [];
                return;
            end
    end
end

end

%----------------------------------------------------------------------%

function P = InitializeP
	%--experiment parameters----------------------------------
	P = struct;
    
    P.stim = struct(...
        'figure',       1:4, ...
        'operation',    1:4  ...
        );
    
	P.exp = struct(...
		'nRun',				10,	...
		'fracProbe',		.2,	... fraction of blocks with probe
		'fracProbeCorrect',	.5,	...	fraction of probes that are a match
		'fracMatchW',		.5,	... of the correct probes, fraction that match the working memory image
		'nCondRep',			1	...
		);
	P.exp.nNoProbe = numel(P.stim.figure) * numel(P.stim.operation) * P.exp.nCondRep;
    P.exp.nProbe = ceil(P.exp.fracProbe * P.exp.nNoProbe / (1 - P.exp.fracProbe));
    P.exp.nProbeTotal = P.exp.nProbe * P.exp.nRun; % total # of probes in experiment
    P.exp.nBlock = P.exp.nProbe + P.exp.nNoProbe;
    
	P.trTime = 2; % seconds
	P.time = struct(... all times in TRs
		'mapping', 	3,	... shows for *at least* this long
		'rest',     5,  ...
		'prompt',	1,	...
		'blank',	1,	...
		'task',		2,	...
		'probe',	1,	... on nonprobe blocks, stimulus does not change for "probe" period
        'feedback', 1,  ... same deal (for probe blocks, shape changes color and reward is shown)
		'postrun',  3   ...
		);
	P.time.block = P.time.prompt + P.time.blank + ...
		P.time.task + P.time.probe;
	P.time.run = P.time.mapping + P.time.postrun + ...
		P.exp.nBlock * (P.time.block + P.time.feedback) + ...
		(P.exp.nBlock - 1) * P.time.rest;
    
    P.reward = struct(...
        'base'  ,   20, ...
        'max'   ,   40, ...
        'penalty',  5   ... penalty is this number times reward
        );
    P.reward.rewardPerBlock = (P.reward.max - P.reward.base) / P.exp.nProbeTotal;
    P.reward.penaltyPerBlock = P.reward.rewardPerBlock * P.reward.penalty;
    
	%--display parameters-------------------------------------
	P.color = struct(...
		'back',     [127 127 127], ...
		'fore',     [0   0   0  ], ...
		'probe',	[0   0   255], ...	
		'yes',      [0   255 0  ], ...
		'no',       [255 0   0  ]  ...
		);
	P.text = struct(...
		'size',     [],     ... (d.v.a.)
		'family',   'Arial',...
        'offset',   4,      ...
        'colNorm',  'black',...
        'colYes',   'green',...
        'colNo',    'red',  ...
        'sizeDone', 3.5,    ... (d.v.a.)
        'colDone',  'red',  ...
        'sizePrompt', 2     ...
		);
	P.size = struct(... d.v.a. unless otherwise indicated
		'stimpx',   	200,	...
		'stim', 		5.5,		...
        'probe',        3.5      ...
		);
	% copied from gridop
	P.shape = struct(...
		'rect'	, {{[0 1 1 1; 0 1 0 0; 0 1 0 0; 1 1 0 0],[1 1 1 1; 0 1 0 0; 0 1 0 0; 0 1 0 0]}}	, ...
		'polar'	, {{[1 1 0 1; 1 1 0 1; 0 1 0 0; 0 1 0 0],[0 0 1 0; 1 1 1 0; 1 1 0 0; 1 1 0 0]}}	, ...
		'rect_f', 0.94 ...
		);
    P.prompt = struct(...
        'stimulus'  ,   'ABCD', ...
        'operation' ,   '1234', ...
        'distance'  ,   4, ... dva
        'arrow'     ,   1.5 ...
        );
    
    %--input parameters---------------------------------------
    P.key = struct(...
        'response'  ,   {{'left','right'}}, ...
        'match'     ,   'left',             ...
        'noMatch'   ,   'right'             ...
        );
end

