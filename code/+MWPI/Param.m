function p = Param(varargin)
% MWPI.Param
% 
% Description:	get a mwpi parameter
% 
% Syntax:	p = MWPI.Param(f1,...,fN)
% 
% In:
% 	fK	- the the Kth parameter field
% 
% Out:
% 	p	- the parameter value
%
% Example:
%	p = MWPI.Param('color','back');
%
% Updated: 2015-06-24

% struct to hold param values
persistent P;

if isempty(P)
   P = InitializeP;
end

% get parameter value
p = P;
for k = 1:nargin
    field = varargin{k};
    switch class(field)
        case 'char'
            if isfield(p, field)
                p = p.(field);
            else
                p = [];
                return;
            end
        otherwise
            if iscell(p) % if we're indexing into a cell
                p = p{field};
            else
                p = [];
                return;
            end
    end
end

end

%----------------------------------------------------------------------%

function P = InitializeP
	%--experiment parameters----------------------------------
	P = struct;
    
    P.stim = struct(...
        'figure',       1:4, ...
        'operation',    1:4  ...
        );
    
	P.exp = struct(...
		'nRun',				10,	...
		'nProbe',   		4,  ... blocks with probe (figures are balanced if multiple of 4)
		'fracProbeCorrect',	.5,	...	fraction of probes that are a match
		'fracMatchW',		.5,	... of the correct probes, fraction that match the working memory image
		'nCondRep',			2	... number of times to repeat the 4 figures (in nonprobe trials)
		);
	P.exp.nNoProbe = numel(P.stim.figure) * P.exp.nCondRep;
    P.exp.nProbeTotal = P.exp.nProbe * P.exp.nRun; % total # of probes in experiment
    P.exp.nBlock = P.exp.nProbe + P.exp.nNoProbe;
	
	% P.practice: chunkLen is an array of integers that specify the
	% number of blocks to show in a chunk of each type; the mapping is
	% presented before each chunk. freq specifies the number of chunks
	% to run of each type. The practice run proceeds in the order of these
	% vectors. For instance, if chunkLen = [1; 2] and freq = [8; 5],
	% this will translate to 18 total blocks, with the mapping shown
	% before each of the first 8 blocks, then before each pair of the last
	% 10.
	% tWaitRest is the number of milliseconds to wait between blocks.
	% tWaitFeedback is the number of milliseconds to wait during feedback.
	% Other fields mirror P.exp.
	P.practice = struct(...
		'chunkLen',			[1;  2; 4; 8],  ...
		...'freq'	  ,			[10; 5; 1; 1], ...
		'freq',[1;1;0;0],...
		'nNoProbe',			0,  ...
		'nCondRep',			0,	...
		'fracProbeCorrect', .5, ...
		'fracMatchW',		.5, ...
		'tWaitRest',		6000, ...
		'tWaitFeedback',	2000  ...
	);
	P.practice.nProbe = sum(P.practice.chunkLen .* P.practice.freq);
	P.practice.nBlock = P.practice.nProbe;
    
	P.trTime = 2; % seconds
	P.time = struct(... all times in TRs
		'mapping',		 2,	... shows for *at least* this long
		'pre',			 1, ...
		'rest',			 4, ...
		'prompt',		 1,	...
		'task',			 5,	...
		'probeDelay',	 1.5, ... probe won't appear before start of "task" + "probeDelay"
		'probeOn',		 0.2, ... amount of time probe flashes on screen
		'probeOff',		 0.8, ... time to respond after probe disappears
        'feedback',		 1  ... only for probe blocks
		);
	P.time.probe = P.time.probeOn + P.time.probeOff;
	P.time.block = P.time.prompt + P.time.task;
	P.time.run = P.time.mapping + P.time.pre + ...
		P.exp.nBlock * (P.time.block + P.time.rest) + ...
		P.exp.nProbe * P.time.feedback;
    
    P.reward = struct(...
        'base'  ,   20, ...
        'max'   ,   40, ...
        'penalty',  5   ... penalty is this number times reward
        );
    P.reward.rewardPerBlock = (P.reward.max - P.reward.base) / P.exp.nProbeTotal;
    P.reward.penaltyPerBlock = P.reward.rewardPerBlock * P.reward.penalty;
    
	%--display parameters-------------------------------------
	P.color = struct(...
		'back',     [127 127 127], ...
		'fore',     [0   0   0  ], ...
		'probe',	[64  64  64 ], ...	
		'yes',      [0   255 0  ], ...
		'no',       [255 0   0  ], ...
		'arrowBack',[0   0   0   0] ...
		);
	P.text = struct(...
		'size',     0.75,     ... (d.v.a.)
		'family',   'Arial',...
        'fbOffset',   5,      ...
        'colNorm',  'black',...
        'colYes',   'green',...
        'colNo',    'red',  ...
        'sizeDone', 3.5,    ... (d.v.a.)
        'colDone',  'red'  ...
		);
	P.size = struct(... d.v.a. unless otherwise indicated
		'stimpx',   	400,	...
		'stim', 		10,		...
        'probe',        6.5      ...
		);
	% copied from gridop
	P.shape = struct(...
		'rect'	, {{[0 1 1 1; 0 1 0 0; 0 1 0 0; 1 1 0 0],[1 1 1 1; 0 1 0 0; 0 1 0 0; 0 1 0 0]}}	, ...
		'polar'	, {{[1 1 0 1; 1 1 0 1; 0 1 0 0; 0 1 0 0],[0 0 1 0; 1 1 1 0; 1 1 0 0; 1 1 0 0]}}	, ...
		'rect_f', 0.94 ...
		);
    P.prompt = struct(...
        'stimulus'  ,   'ABCD', ...
        'operation' ,   '1234', ...
		'color'		,	'white',...
		'size_mult'	,	0.5		...
        );
	P.prompt.text      = 2   * P.prompt.size_mult;
	P.prompt.distance  = 4   * P.prompt.size_mult;
	P.prompt.arrow	   = 1.5 * P.prompt.size_mult;
    
    %--input parameters---------------------------------------
    P.key = struct(...
        'response'  ,   {{'left','right'}}, ...
        'match'     ,   'left',             ...
        'noMatch'   ,   'right'             ...
        );
end

